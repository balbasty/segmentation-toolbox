function [obj,munum,muden] = spm_preprocx(obj,logtpm)
% Combined Segmentation and Spatial Normalisation
%
% FORMAT results = spm_preproc8(obj)
%
% obj is a structure, and must have the following fields...
%    image    - a structure (array) of handles of individual scans,
%               of the sort returned by spm_vol.  Data can be
%               multispectral, with N channels, but files must be in
%               voxel-for-voxel alignment.
%    biasfwhm - FWHM of bias field(s). There are N elements, one for
%               each channel.
%    biasreg  - Regularisation of bias field estimation. N elements.
%    tpm      - Tissue probability map data, as generated by
%               spm_load_priors.  This would represent Kb different
%               tissue classes - including air (background).
%    lkp      - A lookup table indicating which Gaussians should be used
%               with each of the Kb tissue probability maps.  For example,
%               if there are 6 tissue types, with two Gaussians to
%               represent each, except the 5th, which uses 4 Gaussians,
%               then lkp=[1,1,2,2,3,3,4,4,5,5,5,5,6,6].
%    Affine   - a 4x4 affine transformation matrix, such that the mapping
%               from voxels in the individual to those in the template
%               is by tpm.M\Affine*obj.image(1).mat.
%    reg      - Regularisation for the nonlinear registration of the
%               template (tissue probability maps) to the individual.
%    samp     - The distance (mm) between samples.  In order to achieve
%               a reasonable speed, not all voxels in the images are
%               used for the parameter estimation.  Better segmentation
%               would be expected if all were used, but this would be
%               extremely slow.
%    fwhm     - A smoothness estimate for computing a fudge factor that
%               tries to account for spatial covariance in the noise.
%
% obj also has some optional fields...
%    mg       - a 1xK vector (where K is the lengrh of obj.lkp). This
%               represents the mixing proportions within each tissue.
%    mn       - an NxK matrix containing the means of the Gaussians.
%    vr       - an NxNxK matrix containing the covariances of each of
%               the Gaussians.
%    Tbias    - a cell array encoding the parameterisation of each bias
%               field.
%    Twarp    - the encoding of the nonlinear deformation field.
%
% Various estimated parameters are saved as fields of the results
% structure.  Some of these are taken from the input, whereas others
% are estimated or optimised...
%    results.image  = obj.image;
%    results.tpm    = obj.tpm.V;
%    results.Affine = obj.Affine;
%    results.lkp    = obj.lkp;
%    results.MT     = an affine transform used in conjunction with the
%                     parameterisation of the warps.
%    results.Twarp  = obj.Twarp;
%    results.Tbias  = obj.Tbias;
%    results.mg     = obj.mg;
%    results.mn     = obj.mn;
%    results.vr     = obj.vr;
%    results.ll     = Log-likelihood.
%
%_______________________________________________________________________
% The general principles are described in the following paper, but some
% technical details differ.  These include a different parameterisation
% of the deformations, the ability to use multi-channel data and the
% use of a fuller set of tissue probability maps.  The way the mixing
% proportions are dealt with is also slightly different.
%
% Ashburner J & Friston KJ. "Unified segmentation".
% NeuroImage 26(3):839-851 (2005).
%_______________________________________________________________________
% Copyright (C) 2008 Wellcome Trust Centre for Neuroimaging

% John Ashburner
% $Id: spm_preproc8.m 7172 2017-09-21 16:31:30Z john $

wp_reg    = 1; % Bias wp towards 1

tol1      = 1e-4; % Stopping criterion.  For more accuracy, use a smaller value

V         = obj.image;
Affine    = obj.Affine;
M         = logtpm.M\Affine*V(1).mat;
d0        = V(1).dim(1:3);
dtpm      = logtpm.d;
vx        = sqrt(sum(V(1).mat(1:3,1:3).^2));
sk        = max([1 1 1],round(obj.samp*[1 1 1]./vx));
[x0,y0,o] = ndgrid(1:sk(1):d0(1),1:sk(2):d0(2),1);
z0        = 1:sk(3):d0(3);
tiny      = eps*eps;
lkp       = obj.lkp;
if isempty(lkp)
    K         = 2000;
    Kb        = numel(logtpm.dat);
    use_mog   = false;
    use_vbmog = false;
else
    K       = numel(obj.lkp);
    Kb      = max(obj.lkp);
    if obj.use_vbmog
        use_vbmog = true;
        use_mog   = false;
    else
        use_vbmog = false;
        use_mog   = true;
    end
end
% lkpsemi = obj.lkpsemi;

kron = @(a,b) spm_krutil(a,b);

niter      = obj.niter;
niter1     = obj.niter1;
nsubitmog  = obj.nsubitmog;
nsubitbf   = obj.nsubitbf;
nitdef     = obj.nitdef;
niter_stop = obj.niter_stop;

dobias = obj.dobias;
dodef  = obj.dodef;
dotpm  = obj.dotpm;

% Some random numbers are used, so initialise random number generators to
% give the same results each time.
rng('default');
rng(1);

% Fudge Factor - to (approximately) account for non-independence of voxels.
% Note that variances add, and that Var[a*x + b*y] = a^2*Var[x] + b^2*Var[y]
% Therefore the variance of i.i.d. noise after Gaussian smoothing is equal
% to the sum of the Gaussian function squared times the original variance.
% A Gaussian is given by g=sqrt(2*pi*s^2)^(-1/2)*exp(-0.5*x.^2/s^2);
% After squaring, this is (2*pi*s^2)^(-1)*exp(-x.^2/s^2), which is a scaled
% Gaussian. Letting s2 = 2/sqrt(2), this is equal to
% (4*pi*s^2)^(-1/2)*(2*pi*s2^2)^(-1/2)*exp(-0.5*x.^2/s2^2), from which
% the (4*pi*s^2)^(-1/2) factor comes from.
fwhm = obj.fwhm;                            % FWHM of image smoothness
vx   = sqrt(sum(V(1).mat(1:3,1:3).^2));     % Voxel size
fwhm = fwhm+mean(vx); 
s    = fwhm/sqrt(8*log(2));                 % Standard deviation
ff   = prod(4*pi*(s./vx./sk).^2 + 1)^(1/2); 

spm_diffeo('boundary',1);

% Initialise Deformation
%-----------------------------------------------------------------------
% This part is fiddly because of the regularisation of the warps.
% The fact that displacement fields are only parameterised every few
% voxels means that the functions in spm_diffeo need tweaking to
% account for the difference between the units of displacement and
% the separation of the voxels (if that makes sense).

% More work/thought is needed in terms of adjusting regularisation to
% account for different voxel sizes.  I'm still not satisfied that
% this (rescaling the regularisaiton by prod(vx.*sk)) is optimal.
% The same thing applies to all the nonlinear warping code in SPM.
param  = [sk.*vx prod(vx.*sk)*ff*obj.reg]; % FIX THIS (remove "prod(vx.*sk)")

% Mapping from indices of subsampled voxels to indices of voxels in image(s).
MT     = [sk(1) 0 0 (1-sk(1));0 sk(2) 0 (1-sk(2)); 0 0 sk(3) (1-sk(3));0 0 0 1];

% For multiplying and dividing displacements to map from the subsampled voxel indices
% and the actual image voxel indices.
sk4    = reshape(sk,[1 1 1 3]);

% Dimensions of sub-sampled image
d      = [size(x0) length(z0)];

if isfield(obj,'Twarp')
    Twarp = obj.Twarp; 
else
    Twarp = zeros([d,3],'single');
end
llr = -0.5*sum(sum(sum(sum(Twarp.*bsxfun(@times,spm_diffeo('vel2mom',bsxfun(@times,Twarp,1./sk4),param),1./sk4)))));

% Initialise bias correction
%-----------------------------------------------------------------------
N    = numel(V);
cl   = cell(N,1);
args = {'C',cl,'B1',cl,'B2',cl,'B3',cl,'T',cl,'ll',cl};
if use_mog || use_vbmog
    chan = struct(args{:});
else
    chan = struct(args{:},'hist',cl,'lik',cl,'alph',cl,'grad',cl,'lam',cl,'interscal',cl);
end

for n=1:N
    % GAUSSIAN REGULARISATION for bias correction
    fwhm    = obj.biasfwhm(n);
    biasreg = obj.biasreg(n);
    vx      = sqrt(sum(V(n).mat(1:3,1:3).^2));
    d0      = V(n).dim;
    sd      = vx(1)*d0(1)/fwhm; d3(1) = ceil(sd*2); krn_x   = exp(-(0:(d3(1)-1)).^2/sd.^2)/sqrt(vx(1));
    sd      = vx(2)*d0(2)/fwhm; d3(2) = ceil(sd*2); krn_y   = exp(-(0:(d3(2)-1)).^2/sd.^2)/sqrt(vx(2));
    sd      = vx(3)*d0(3)/fwhm; d3(3) = ceil(sd*2); krn_z   = exp(-(0:(d3(3)-1)).^2/sd.^2)/sqrt(vx(3));
    Cbias   = kron(krn_z,kron(krn_y,krn_x)).^(-2)*biasreg*ff;
    chan(n).C   = sparse(1:length(Cbias),1:length(Cbias),Cbias,length(Cbias),length(Cbias));

    % Basis functions for bias correction
    chan(n).B3  = spm_dctmtx(d0(3),d3(3),z0);
    chan(n).B2  = spm_dctmtx(d0(2),d3(2),y0(1,:)');
    chan(n).B1  = spm_dctmtx(d0(1),d3(1),x0(:,1));

    % Initial parameterisation of bias field
    if isfield(obj,'Tbias') && ~isempty(obj.Tbias{n})
        chan(n).T = obj.Tbias{n};
    else
        chan(n).T   = zeros(d3);
    end
end

if isfield(obj,'msk') && ~isempty(obj.msk)
    VM = spm_vol(obj.msk);
    if sum(sum((VM.mat-V(1).mat).^2)) > 1e-6 || any(VM.dim(1:3) ~= V(1).dim(1:3))
        error('Mask must have the same dimensions and orientation as the image.');
    end
end

% Load the data
%-----------------------------------------------------------------------
nm    = 0; % Number of voxels
sumnm = zeros(N,1);

scrand = zeros(N,1);
for n=1:N
    if spm_type(V(n).dt(1),'intt')
        scrand(n) = V(n).pinfo(1);
    end
end

% Overall moments used later for regularising via a ``Wishart-style prior''
mom0 = zeros(1,N);
mom1 = zeros(1,N);
mom2 = zeros(1,N);

cl   = cell(length(z0),1);
buf  = struct('msk',cl,'nm',cl,'f',cl,'dat',cl,'bf',cl);
for z=1:length(z0)
    if ~dotpm && d(3)>1
        % Load only those voxels that are more than 5mm up
        % from the bottom of the tissue probability map.  This
        % assumes that the affine transformation is pretty close.
	 
        %x1  = M(1,1)*x0 + M(1,2)*y0 + (M(1,3)*z0(z) + M(1,4));
        %y1  = M(2,1)*x0 + M(2,2)*y0 + (M(2,3)*z0(z) + M(2,4));
        z1  = M(3,1)*x0 + M(3,2)*y0 + (M(3,3)*z0(z) + M(3,4));
        e   = sqrt(sum(logtpm.M(1:3,1:3).^2));
        e   = 5./e; % mm from edge of TPM
        buf(z).msk = z1>e(3);
    else
        buf(z).msk = ones(d(1:2),'logical');
    end
    
    % Initially load all the data, but prepare to exclude
    % locations where any of the images is not finite, or
    % is zero.  We want this to work for skull-stripped
    % images too.
    fz = cell(1,N);
    for n=1:N
        fz{n}      = spm_sample_vol(V(n),x0,y0,o*z0(z),0);
        buf(z).msk = buf(z).msk & get_msk(fz{n});
    end

    if isfield(obj,'msk') && ~isempty(obj.msk)
        % Exclude any voxels to be masked out
        msk        = spm_sample_vol(VM,x0,y0,o*z0(z),0);
        buf(z).msk = buf(z).msk & msk;
    end
    
    % Sum up intensities of all voxels
    buf(z).nm  = sum(buf(z).msk(:));
    nm         = nm + buf(z).nm;
    for n=1:N
        sumnm(n) = sumnm(n) + sum(fz{n}(buf(z).msk));
    end
end

a = zeros(1,N);
for z=1:length(z0)  
    for n=1:N                   
        fz = spm_sample_vol(V(n),x0,y0,o*z0(z),0);
        
        % To "normalise" image intensities        
        if strcmp(V(n).descrip,'CT')
            a(n) = 1.0;
        else
            a(n) = 512/(sumnm(n)/nm);
        end
       
        % Eliminate unwanted voxels
        if scrand(n)
            % Data is an integer type, so to prevent aliasing in the histogram, small
            % random values are added.  It's not elegant, but the alternative would be
            % too slow for practical use.
            buf(z).f{n}  = single(a(n)*fz(buf(z).msk)+rand(buf(z).nm,1)*scrand(n)-scrand(n)/2);
        else
            buf(z).f{n}  = single(a(n)*fz(buf(z).msk));
        end     
        
        mom0(n) = mom0(n) + buf(z).nm;
        mom1(n) = mom1(n) + sum(buf(z).f{n});
        mom2(n) = mom2(n) + sum(buf(z).f{n}.^2);
    end

    % Create a buffer for tissue probability info
    buf(z).dat = zeros([buf(z).nm,Kb],'single');
end

if ~use_vbmog
    % Construct a ``Wishart-style prior'' (vr0)
    vr0 = diag(mom2./mom0 - (mom1./mom0).^2)/Kb^2;
    %for n=1:N
    %    if spm_type(V(n).dt(1),'intt')
    %        vr0(n,n) = vr0(n,n) + 0.083*V(n).pinfo(1,1);
    %    end
    %end
end

% Create initial bias field
%-----------------------------------------------------------------------
llrb = 0;
for n=1:N
    B1 = chan(n).B1;
    B2 = chan(n).B2;
    B3 = chan(n).B3;
    C  = chan(n).C;
    T  = chan(n).T;
    chan(n).ll = double(-0.5*T(:)'*C*T(:));
    for z=1:numel(z0)
        bf           = transf(B1,B2,B3(z,:),T);
        tmp          = bf(buf(z).msk);
        chan(n).ll   = chan(n).ll + double(sum(tmp));
        buf(z).bf{n} = single(exp(tmp));
    end
    llrb = llrb + chan(n).ll;
    clear B1 B2 B3 T C tmp
end

if isfield(obj,'wp')
    wp = obj.wp;
else
    wp = ones(1,Kb)/Kb;
end

% % Set weigths to zero and re-normalise (for semi-supervised approach)
% wp(lkpsemi) = eps;
% wp          = wp/sum(wp);

% For debugging
%-----------------------------------------------------------------------
zslice   = floor(d(3)/2 + 1);
fig      = obj.fig;
conv_def = zeros(1,nitdef + 1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Run algorithm
%------------------------------------------------------------

spm_plot_convergence('Init','Initialising','Log-likelihood','Iteration');

ll = -Inf;
for iter=1:niter

    % Load the warped prior probability images into the buffer
    %------------------------------------------------------------
    for z=1:length(z0)
        if ~buf(z).nm, continue; end
        [x1,y1,z1] = defs(Twarp,z,x0,y0,z0,M,buf(z).msk);        
        b          = spm_sample_logpriors8(logtpm,x1,y1,z1);
        for k1=1:Kb
            buf(z).dat(:,k1) = b{k1};
        end        
    end

    % Starting estimates for intensity distribution parameters
    %------------------------------------------------------------
    if iter==1        
        if use_mog || use_vbmog 
            % Starting estimates for Gaussian parameters
            %--------------------------------------------------------------
            if isfield(obj,'mg') && (isfield(obj,'po') && isfield(obj,'pr') || isfield(obj,'mn') && isfield(obj,'vr'))
                % Use already estimated parameters
                mg = obj.mg;
                if isfield(obj,'po') && isfield(obj,'pr')                  
                    po = obj.po;
                    pr = obj.pr;
                elseif isfield(obj,'mn') && isfield(obj,'vr')                    
                    mn = obj.mn;
                    vr = obj.vr;
                end
            else                
                K   = Kb;
                lkp = 1:Kb;
                
                mg  = ones(Kb,1); % Within tissue mixture weights
                
                if use_vbmog
                    % Initial Gaussian-Wishart priors
                    pr.m = zeros(N,Kb);
                    pr.b = ones(1,Kb);
                    pr.W = zeros(N,N,Kb);
                    for k=1:Kb
                        pr.W(:,:,k) = eye(N,N);
                    end
                    pr.n = (N + 1)*ones(1,Kb);
                end
                    
                if ~logtpm.uniform
                    % Use data and tpm to estimate parameters

                    % Begin with moments:
                    mm0 = zeros(Kb,1) + tiny;
                    mm1 = zeros(N,Kb);
                    mm2 = zeros(N,N,Kb);
                    for z=1:length(z0)
                        cr = zeros(size(buf(z).f{1},1),N);
                        for n=1:N
                            cr(:,n)  = double(buf(z).f{n}.*buf(z).bf{n});
                        end
                        for k1=1:Kb, % Moments
                            b           = double(buf(z).dat(:,k1));
                            mm0(k1)     = mm0(k1)     + sum(b);
                            mm1(:,k1)   = mm1(:,k1)   + (b'*cr)';
                            mm2(:,:,k1) = mm2(:,:,k1) + (repmat(b,1,N).*cr)'*cr;
                        end
                        clear cr b
                    end

                    if use_vbmog                                                
                        % Use moments to compute initial Gaussian-Wishart
                        % posteriors
                        [mm1,mm2] = mom_John2Bishop(mm0,mm1,mm2);

                        po.b = pr.b + mm0';
                        po.n = pr.n + mm0';
                        po.m = zeros(N,Kb);
                        po.W = zeros(N,N,Kb);
                        for k=1:Kb
                            po.m(:,k)   = (pr.b(k)*pr.m(:,k) + mm0(k).*mm1(:,k))./po.b(k);

                            invW0       = inv(pr.W(:,:,k));
                            mlt1        = pr.b(k).*mm0(k)/(pr.b(k) + mm0(k));
                            diff1       = mm1(:,k) - pr.m(:,k);
                            po.W(:,:,k) = inv(invW0 + mm0(k)*mm2(:,:,k) + mlt1*(diff1*diff1'));
                        end  
                    else       
                        % Use moments to compute means and variances, and then use these
                        % to initialise the Gaussians
                        mn = zeros(N,Kb);
                        vr = zeros(N,N,Kb);
                        vr1 = zeros(N,N);
                        for k1=1:Kb
                            mn(:,k1)   = mm1(:,k1)/(mm0(k1)+tiny);
                           %vr(:,:,k1) = (mm2(:,:,k1) - mm1(:,k1)*mm1(:,k1)'/mm0(k1))/(mm0(k1)+tiny);
                            vr1 = vr1 + (mm2(:,:,k1) - mm1(:,k1)*mm1(:,k1)'/mm0(k1));
                        end
                        vr1 = (vr1+N*vr0)/(sum(mm0)+N);
                        for k1=1:Kb
                            vr(:,:,k1) = vr1;
                        end
                    end                
                else
                    % Use a k-means algorithm to get parameter estimates
                    [wp2,mn2,vr2] = spm_InitGaussians(buf,Kb);                    
                    
                    if use_vbmog
                        % Use 'responsibilities' from initialization to set sufficient statistics
                        mm0 = nm*wp2;
                        mm1 = mn2;
                        mm2 = vr2;

                        po.b = pr.b + mm0;
                        po.n = pr.n + mm0;
                        po.m = zeros(N,Kb);
                        po.W = zeros(N,N,Kb);
                        for k=1:Kb
                            po.m(:,k)   = (pr.b(k)*pr.m(:,k) + mm0(k).*mm1(:,k))./po.b(k);

                            invW0    = inv(pr.W(:,:,k));
                            mlt1     = pr.b(k).*mm0(k)/(pr.b(k) + mm0(k));
                            diff1    = mm1(:,k) - pr.m(:,k);
                            po.W(:,:,k) = inv(invW0 + mm0(k)*mm2(:,:,k) + mlt1*(diff1*diff1'));
                        end  
                    else               
                        mn = mn2;
                        vr = vr2;    
                    end
                    clear wp2 mn2 vr2 
                end
            end
        else
            % Starting estimates for histograms
            %-----------------------------------------------------------------------
            for n=1:N
                maxval = -Inf;
                minval =  Inf;
                for z=1:length(z0)
                    if ~buf(z).nm, continue; end
                    maxval = max(max(buf(z).f{n}),maxval);
                    minval = min(min(buf(z).f{n}),minval);
                end
                maxval = max(maxval*1.5,-minval*0.05); % Account for bias correction effects
                minval = min(minval*1.5,-maxval*0.05);
                chan(n).interscal = [1 minval; 1 maxval]\[1;K];
                h0     = zeros(K,Kb);
                for z=1:length(z0)
                    if ~buf(z).nm, continue; end
                    cr       = round(buf(z).f{n}.*buf(z).bf{n}*chan(n).interscal(2) + chan(n).interscal(1));
                    cr       = min(max(cr,1),K);
                    for k1=1:Kb
                        h0(:,k1) = h0(:,k1) + accumarray(cr,buf(z).dat(:,k1),[K,1]);
                    end
                end
                chan(n).hist = h0;
            end
        end
    end

    for iter1=1:niter1
        if use_mog || use_vbmog
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % Estimate cluster parameters
            %------------------------------------------------------------            
           
            for subitmog=1:nsubitmog
                
                oll  = ll;
                mom0 = zeros(K,1)+tiny; % Initialise moments
                mom1 = zeros(N,K);
                mom2 = zeros(N,N,K);
                mgm  = zeros(1,Kb);
                ll   = llr+llrb;
                for z=1:length(z0)
                    if ~buf(z).nm, continue; end
                    B   = double(buf(z).dat);
                    s   = 1./(B*wp');
                    mgm = mgm + s'*B;
                                        
                    % Calculate responsibilities
                    if use_mog
                        [q,dll] = latent(buf(z).f,buf(z).bf,mg,mn,vr,B,lkp,wp);                   
                    elseif use_vbmog
                        [q,dll] = latent_vb(buf(z).f,buf(z).bf,mg,po,B,lkp,wp);                    
                    end
                    ll = ll + dll;

                    cr  = zeros(size(q,1),N);
                    for n=1:N
                        cr(:,n)  = double(buf(z).f{n}.*buf(z).bf{n});
                    end
                    for k=1:K, % Update moments
                        mom0(k)     = mom0(k)     + sum(q(:,k));
                        mom1(:,k)   = mom1(:,k)   + (q(:,k)'*cr)';
                        mom2(:,:,k) = mom2(:,:,k) + (repmat(q(:,k),1,N).*cr)'*cr;
                    end
                    clear cr                                        
                end
                
                % Update within tissue mixing proportions
                for k=1:K
                    tmp   = mom0(lkp==lkp(k));
                    mg(k) = (mom0(k) + tiny)/sum(tmp + tiny);  % US eq. 27 (partly)
                end
                
                % Update between tissue weights
                for k1=1:Kb
                    wp(k1) = (sum(mom0(lkp==k1)) + wp_reg*1)/(mgm(k1) + wp_reg*Kb); % bias the solution towards 1
                end
                wp = wp/sum(wp);
                
%                 % Set weigths to zero and re-normalise (for semi-supervised approach)
%                 wp(lkpsemi) = eps;
%                 wp          = wp/sum(wp);
                
                if use_vbmog
                    [mom1,mom2] = mom_John2Bishop(mom0,mom1,mom2);
                    
                    dll = lowerbound_vb(mom0,mom1,mom2,po,pr);                    
                    ll  = ll + dll;
                end
                
                my_fprintf('MOG:\t%g\t%g\t%g\n', ll,llr,llrb);
                               
                if use_mog
                    % Means and Variances from moments
                    for k=1:K
                        mn(:,k)   = mom1(:,k)/(mom0(k)+tiny);      % US eq. 23
                        vr(:,:,k) = (mom2(:,:,k) - mom1(:,k)*mom1(:,k)'/mom0(k) + N*vr0)/(mom0(k)+N); % US eq. 25
                    end
                elseif use_vbmog
                    % VB-MoG posteriors from moments
                    po = vmstep_vb(mom0,mom1,mom2,pr);                
                end
                
                if subitmog>1 || iter>1
                    spm_plot_convergence('Set',ll);
                end
                if subitmog>1 && ll-oll<tol1*nm
                    % Improvement is small, so go to next step
                    break;
                end
            end  
        else
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % Estimate histogram parameters
            %------------------------------------------------------------

            % Compute regularisation for histogram smoothing
            for n=1:N
               %x = (1:K)';
                for k1=1:Kb
                   %mom0 = sum(chan(n).hist(:,k1)) + eps;
                   %mom1 = sum(chan(n).hist(:,k1).*x) + eps;
                   %chan(n).lam(k1) = sum(chan(n).hist(:,k1).*(x-mom1./mom0).^2+1)/(mom0+1)+1;
                    chan(n).lam(k1) = Kb^2*double(vr0(N,N)*chan(n).interscal(2)^2);
                end
            end

            for subith=1:20
                oll  = ll;
                ll   = llr+llrb;
                for n=1:N
                    chan(n).lik  = spm_smohist(chan(n).hist,chan(n).lam);
                    chan(n).lik  = chan(n).lik*chan(n).interscal(2);
                    chan(n).alph = log(chan(n).lik+eps);
                    chan(n).hist = zeros(K,Kb);
                end
                mgm  = zeros(1,Kb);
                for z=1:length(z0)
                    B   = double(buf(z).dat);
                    s   = 1./(B*wp');
                    mgm = mgm + s'*B;

                    [q,dll] = latent_nonpar(buf(z).f,buf(z).bf,chan,buf(z).dat,wp);
                    ll      = ll + dll;

                    cr  = cell(N,1);
                    for n=1:N
                        tmp   = buf(z).f{n}.*buf(z).bf{n}*chan(n).interscal(2) + chan(n).interscal(1);
                        cr{n} = min(max(round(tmp),1),K);
                    end
                    clear tmp
                    for k1=1:Kb
                        for n=1:N
                            chan(n).hist(:,k1) = chan(n).hist(:,k1) + accumarray(cr{n},q(:,k1),[K,1]);
                        end
                    end
                    clear cr
                end
                wp = (sum(chan(1).hist)+wp_reg*1)./(mgm+wp_reg*Kb);
                wp = wp/sum(wp);

                my_fprintf('Hist:\t%g\t%g\t%g\n', ll,llr,llrb);

                if subith>1 || iter>1
                    spm_plot_convergence('Set',ll); 
                end
                if subith>1 && ll-oll<tol1*nm
                    % Improvement is small, so go to next step
                    break;
                end
            end
            for n=1:N
                chan(n).lik  = spm_smohist(chan(n).hist,chan(n).lam);
                chan(n).lik  = chan(n).lik*chan(n).interscal(2);
                chan(n).alph = log(chan(n).lik+eps);
                chan(n).grad1 = convn(chan(n).alph,[0.5 0 -0.5]'*chan(n).interscal(2),  'same');
                chan(n).grad2 = convn(chan(n).alph,[1  -2  1  ]'*chan(n).interscal(2)^2,'same');
            end
        end

        if ~isempty(fig{1})
            % Visualise responsibilities    
            if use_vbmog
                Btmp = double(buf(zslice).dat);
                qtmp = latent_vb(buf(zslice).f,buf(zslice).bf,mg,po,Btmp,lkp,wp); 
                clear Btmp
            elseif use_mog
                Btmp = double(buf(zslice).dat);
                qtmp = latent(buf(zslice).f,buf(zslice).bf,mg,mn,vr,Btmp,lkp,wp);
                clear Btmp
            else
                qtmp = zeros([prod(buf(zslice).msk) 1],'single');
            end
                
            K1 = floor(sqrt(K));
            K2 = ceil(K/K1); 
            set(0,'CurrentFigure',fig{1});                    
            for i=1:K                                
                tmp                  = zeros(size(buf(zslice).msk),'single');
                tmp(buf(zslice).msk) = qtmp(:,i);

                subplot(K1,K2,i);
                imagesc(tmp'); axis image xy off; title(['k=' num2str(lkp(i))]); colormap(gray);
            end              
        end
        
        if ~isempty(fig{3})
            % Visualise bias field
            set(0,'CurrentFigure',fig{3});                    
            for i=1:N
                tmp                  = zeros(size(buf(zslice).msk),'single');
                tmp(buf(zslice).msk) = buf(zslice).bf{i};

                subplot(1,N,i);
                imagesc(tmp'); axis image xy off; colormap(gray);
            end  
            clear tmp
            
            drawnow
        end
        
        if iter1 > 1 && ~((ll-ooll)>2*tol1*nm),
            break; 
        end
        ooll = ll;

        if dobias
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % Estimate bias
            % Note that for multi-spectral data, the covariances among
            % channels are not computed as part of the second derivatives.
            % The aim is to save memory, and maybe make the computations
            % faster.
            %------------------------------------------------------------

            pr_bf = zeros(N,N,K); % Precisions
            if use_vbmog
                for k=1:K, pr_bf(:,:,k) = po.n(k)*po.W(:,:,k); end
            elseif use_mog
                for k=1:K, pr_bf(:,:,k) = inv(vr(:,:,k)); end
            end

            for subitbf=1:nsubitbf
                for n=1:N
                    d3  = numel(chan(n).T);
                    if d3>0
                        % Compute objective function and its 1st and second derivatives
                        Alpha = zeros(d3,d3); % Second derivatives
                        Beta  = zeros(d3,1);  % First derivatives
                        %ll    = llr+llrb;
                        for z=1:length(z0)
                            if ~buf(z).nm, continue; end

                            if use_mog || use_vbmog                            
                                if use_mog
                                    q = latent(buf(z).f,buf(z).bf,mg,mn,vr,buf(z).dat,lkp,wp);
                                elseif use_vbmog
                                    q = latent_vb(buf(z).f,buf(z).bf,mg,po,buf(z).dat,lkp,wp);
                                end
                                cr = cell(N,1);
                                for n1=1:N, cr{n1} = double(buf(z).f{n1}).*double(buf(z).bf{n1}); end

                                w1 = zeros(buf(z).nm,1);
                                w2 = zeros(buf(z).nm,1);
                                for k=1:K
                                    qk  = q(:,k);
                                    w0  = zeros(buf(z).nm,1);
                                    for n1=1:N
                                        if use_mog
                                            w0 = w0 + pr_bf(n1,n,k)*(mn(n1,k) - cr{n1});
                                        elseif use_vbmog
                                            w0 = w0 + pr_bf(n1,n,k)*(po.m(n1,k) - cr{n1});
                                        end
                                    end
                                    w1  = w1 + qk.*w0;
                                    w2  = w2 + qk*pr_bf(n,n,k);
                                end
                                wt1   = zeros(d(1:2));
                                wt1(buf(z).msk) = -(1 + cr{n}.*w1); % US eq. 34 (gradient)
                                wt2   = zeros(d(1:2));
                                wt2(buf(z).msk) = cr{n}.*cr{n}.*w2 + 1; % Simplified Hessian of US eq. 34
                                clear cr
                            else
                                q   = latent_nonpar(buf(z).f,buf(z).bf,chan,buf(z).dat,wp);
                                cr0 = buf(z).f{n}.*buf(z).bf{n};
                                cr  = cr0*chan(n).interscal(2) + chan(n).interscal(1);
                                cr  = min(max(round(cr),1),K);
                                wt1 = zeros(d(1:2)); 
                                wt2 = zeros(d(1:2));
                                for k1=1:Kb
                                    qk  = q(:,k1);
                                    gr1 = chan(n).grad1(:,k1);
                                    gr1 = gr1(cr);
                                    gr2 = chan(n).grad2(:,k1);
                                    gr2 = min(gr2(cr),0); % Regularise
                                    wt1(buf(z).msk) = wt1(buf(z).msk) - qk.*(gr1.*cr0 + 1);
                                   %wt2(buf(z).msk) = wt2(buf(z).msk) - qk.*(gr1.*cr0 + gr2.*cr0.^2);
                                    wt2(buf(z).msk) = wt2(buf(z).msk) + qk.*(1 - gr2.*cr0.^2);
                                end
                            end

                            b3    = chan(n).B3(z,:)';
                            Beta  = Beta  + kron(b3,spm_krutil(wt1,chan(n).B1,chan(n).B2,0));
                            Alpha = Alpha + kron(b3*b3',spm_krutil(wt2,chan(n).B1,chan(n).B2,1));
                            clear wt1 wt2 b3
                        end

                        oll     = ll;
                        C       = chan(n).C; % Inverse covariance of priors
                        oldT    = chan(n).T;

                        % Gauss-Newton update of bias field parameters
                        Update  = reshape((Alpha + C)\(Beta + C*chan(n).T(:)),size(chan(n).T));
                        clear Alpha Beta

                        armijo = 1.0;
                        for line_search=1:12
                            chan(n).T = chan(n).T - armijo*Update; % Backtrack if necessary

                            % Re-generate bias field, and compute terms of the objective function
                            chan(n).ll = double(-0.5*chan(n).T(:)'*C*chan(n).T(:));
                            for z=1:length(z0)
                                if ~buf(z).nm, continue; end
                                bf             = transf(chan(n).B1,chan(n).B2,chan(n).B3(z,:),chan(n).T);
                                tmp            = bf(buf(z).msk);
                                if ~use_vbmog
                                    % Because for the VB-MoG, the bias field part of the lower
                                    % bound is included already in latent_vb
                                    chan(n).ll = chan(n).ll + double(sum(tmp));
                                end
                                buf(z).bf{n}   = single(exp(tmp));
                            end
                            llrb = 0;
                            for n1=1:N, llrb = llrb + chan(n1).ll; end
                            ll   = llr+llrb;
                            if use_vbmog
                                mom0 = zeros(K,1)+tiny;
                                mom1 = zeros(N,K);
                                mom2 = zeros(N,N,K); 
                            end
                            for z=1:length(z0)
                                if ~buf(z).nm, continue; end
                                if use_vbmog                                    
                                    [q,dll] = latent_vb(buf(z).f,buf(z).bf,mg,po,double(buf(z).dat),lkp,wp);                                                    

                                    cr  = zeros(size(q,1),N);
                                    for n1=1:N
                                        cr(:,n1)  = double(buf(z).f{n1}.*buf(z).bf{n1});
                                    end
                                    for k=1:K,
                                        mom0(k)     = mom0(k)     + sum(q(:,k));
                                        mom1(:,k)   = mom1(:,k)   + (q(:,k)'*cr)';
                                        mom2(:,:,k) = mom2(:,:,k) + (repmat(q(:,k),1,N).*cr)'*cr;
                                    end
                                    clear cr q
                                elseif use_mog                                                               
                                    [~,dll] = latent(buf(z).f,buf(z).bf,mg,mn,vr,double(buf(z).dat),lkp,wp);                                
                                else
                                    [~,dll] = latent_nonpar(buf(z).f,buf(z).bf,chan,double(buf(z).dat),wp);                                
                                end
                                ll = ll + dll;                            
                            end
                            if use_vbmog
                                [mom1,mom2] = mom_John2Bishop(mom0,mom1,mom2);
                                dll         = lowerbound_vb(mom0,mom1,mom2,po,pr);                    
                                ll          = ll + dll; 
                                clear mom0 mom1 mom2
                            end
                            if ll>=oll
                                spm_plot_convergence('Set',ll); 
                                my_fprintf('Bias-%d:\t%g\t%g\t%g :o)\n', n, ll, llr,llrb);
                                break;
                            else
                                ll        = oll;
                                chan(n).T = oldT;
                                armijo    = armijo*0.5;
                                my_fprintf('Bias-%d:\t%g\t%g\t%g :o(\n', n, ll, llr,llrb);
                            end 
                        end
                        clear oldT
                    end
                end
                if subitbf > 1 && ~(ll-oll>tol1*nm)
                    % Improvement is only small, so go to next step
                    break;
                end
            end
        end

        if iter==1 && iter1==1
            % Most of the log-likelihood improvements are in the first iteration.
            % Show only improvements after this, as they are more clearly visible.
            spm_plot_convergence('Clear'); 
            spm_plot_convergence('Init','Processing','Log-likelihood','Iteration'); 

            if numel(obj.lkp) ~= numel(lkp)
                lkp = obj.lkp;
                K   = numel(lkp);
                Kb  = max(lkp);
                mg  = ones(K,1)/K;
                
                if use_mog                  
                    mn1 = mn;
                    vr1 = vr;
                    
                    mn = ones(N,K);
                    vr = zeros(N,N,K);
                elseif use_vbmog
                    m1 = po.m;
                    b1 = po.b;
                    W1 = po.W;
                    n1 = po.n;
                    
                    m0 = pr.m;
                    b0 = pr.b;
                    W0 = pr.W;
                    n0 = pr.n;
                    
                    po.m = zeros(N,K);
                    po.b = zeros(1,K);
                    po.W = zeros(N,N,K);
                    po.n = zeros(1,K);
                    
                    pr.m = po.m;
                    pr.b = po.b;
                    pr.W = po.W;
                    pr.n = po.n;
                end

                for k1=1:Kb
                    % A crude heuristic to replace a single Gaussian by a bunch of Gaussians
                    % If there is only one Gaussian, then it should be the same as the
                    % original distribution.
                    kk 	        = sum(lkp==k1);
                    mg(lkp==k1) = 1/kk;
                    w  		    = 1./(1 + exp(-(kk-1)*0.25)) - 0.5; 
                    
                    if use_mog
                        mn(:,lkp==k1)   = sqrtm(vr1(:,:,k1))*randn(N,kk)*w + repmat(mn1(:,k1),[1,kk]);
                        vr(:,:,lkp==k1) = repmat(vr1(:,:,k1)*(1 - w),[1,1,kk]);
                    elseif use_vbmog
                        vr1               = inv(n1(k1)*W1(:,:,k1));
                        pr1               = inv(vr1*(1 - w));                        
                        po.b(lkp==k1)     = b1(k1);
                        po.m(:,lkp==k1)   = sqrtm(vr1)*randn(N,kk)*w + repmat(m1(:,k1),[1,kk]);
                        po.n(lkp==k1)     = n1(k1);
                        po.W(:,:,lkp==k1) = repmat(pr1/n1(k1),[1 1 kk]);

                        pr.b(lkp==k1)     = b0(k1);
                        pr.m(:,lkp==k1)   = repmat(m0(:,k1),[1,kk]);
                        pr.n(lkp==k1)     = n0(k1);
                        pr.W(:,:,lkp==k1) = repmat(W0(:,:,k1),[1 1 kk]);
                    end                                        
                end 
                clear mn1 vr1 pr1 m1 b1 W1 n1 m0 b0 W0 n0                
            end
        end
    end

    if dodef
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Estimate deformations
        %------------------------------------------------------------
        
        conv_def(1) = conv_def(1) + 1;
        
        % Compute likelihoods, and save them in buf.dat
        ll_const = 0;
        ll       = llr + llrb;                
        if use_vbmog
            for z=1:length(z0)
                if ~buf(z).nm, continue; end
                q        = zeros(buf(z).nm,Kb);
                qt       = log_likelihoods_vb(buf(z).f,buf(z).bf,po,mg);
                max_qt   = max(qt,[],2);
                for k1=1:Kb
                    for k=find(lkp==k1)
                        q(:,k1) = q(:,k1) + exp(qt(:,k)-max_qt);
                    end
                    buf(z).dat(:,k1) = single(q(:,k1));
                end
            end
            dll = objval_vb(buf,N,K,Kb,lkp,x0,y0,z0,Twarp,M,logtpm,mg,po,pr,wp);
            ll  = ll + dll;
        elseif use_mog
            for z=1:length(z0)
                if ~buf(z).nm, continue; end
                q        = zeros(buf(z).nm,Kb);
                qt       = log_likelihoods(buf(z).f,buf(z).bf,mg,mn,vr);
                max_qt   = max(qt,[],2);
                ll_const = ll_const + sum(max_qt);
                B        = bsxfun(@times,double(buf(z).dat),wp);
                B        = bsxfun(@times,B,1./sum(B,2));
                for k1=1:Kb
                    for k=find(lkp==k1)
                        q(:,k1) = q(:,k1) + exp(qt(:,k)-max_qt);
                    end
                    buf(z).dat(:,k1) = single(q(:,k1));
                end
                ll = ll + sum(log(sum(q.*B+tiny,2)));
            end
            ll = ll + ll_const;
        else
            for z=1:length(z0)
                if ~buf(z).nm, continue; end
                q        = log_likelihoods_nonpar(buf(z).f,buf(z).bf,chan);
                max_q    = max(q,[],2);
                ll_const = ll_const + sum(max_q);
                q        = exp(bsxfun(@minus,q,max_q));
                B        = bsxfun(@times,double(buf(z).dat),wp);
                B        = bsxfun(@times,B,1./sum(B,2));
                ll       = ll + sum(log(sum(q.*B+tiny,2)),1);
                buf(z).dat = single(q);
            end
            ll = ll + ll_const;
        end
        
        oll      = ll;        
        for subitdef=1:nitdef
            Alpha  = zeros([size(x0),numel(z0),6],'single');
            Beta   = zeros([size(x0),numel(z0),3],'single');
            for z=1:length(z0)
                if ~buf(z).nm, continue; end

                % Deformations from parameters
                [x1,y1,z1]      = defs(Twarp,z,x0,y0,z0,M,buf(z).msk);

                % Tissue probability map and spatial derivatives
                [b,db1,db2,db3] = spm_sample_logpriors8(logtpm,x1,y1,z1);
                clear x1 y1 z1

                % Adjust for tissue weights
                s   = zeros(size(b{1}));
                ds1 = zeros(size(b{1}));
                ds2 = zeros(size(b{1}));
                ds3 = zeros(size(b{1}));
                for k1=1:Kb
                    b{k1}   = wp(k1)*b{k1};
                    db1{k1} = wp(k1)*db1{k1};
                    db2{k1} = wp(k1)*db2{k1};
                    db3{k1} = wp(k1)*db3{k1};
                    s       =  s  + b{k1};
                    ds1     = ds1 + db1{k1};
                    ds2     = ds2 + db2{k1};
                    ds3     = ds3 + db3{k1};
                end
                for k1=1:Kb
                    b{k1}   = b{k1}./s;
                    db1{k1} = (db1{k1}-b{k1}.*ds1)./s;
                    db2{k1} = (db2{k1}-b{k1}.*ds2)./s;
                    db3{k1} = (db3{k1}-b{k1}.*ds3)./s;
                end
                clear s ds1 ds2 ds3

                % Rotate gradients (according to initial affine registration) and
                % compute the sums of the tpm and its gradients, times the likelihoods
                % (from buf.dat).
                p   = zeros(buf(z).nm,1)+eps;
                dp1 = zeros(buf(z).nm,1);
                dp2 = zeros(buf(z).nm,1);
                dp3 = zeros(buf(z).nm,1);
                MM  = M*MT; % Map from sampled voxels to atlas data
                for k1=1:Kb
                    pp  = double(buf(z).dat(:,k1));
                    p   = p   + pp.*b{k1};
                    dp1 = dp1 + pp.*(MM(1,1)*db1{k1} + MM(2,1)*db2{k1} + MM(3,1)*db3{k1});
                    dp2 = dp2 + pp.*(MM(1,2)*db1{k1} + MM(2,2)*db2{k1} + MM(3,2)*db3{k1});
                    dp3 = dp3 + pp.*(MM(1,3)*db1{k1} + MM(2,3)*db2{k1} + MM(3,3)*db3{k1});
                end
                clear b db1 db2 db3

                % Compute first and second derivatives of the matching term.  Note that
                % these can be represented by a vector and tensor field respectively.
                tmp             = zeros(d(1:2));
                tmp(buf(z).msk) = dp1./p; dp1 = tmp;
                tmp(buf(z).msk) = dp2./p; dp2 = tmp;
                tmp(buf(z).msk) = dp3./p; dp3 = tmp;

                Beta(:,:,z,1)   = -dp1;     % First derivatives
                Beta(:,:,z,2)   = -dp2;
                Beta(:,:,z,3)   = -dp3;

                Alpha(:,:,z,1)  = dp1.*dp1; % Second derivatives
                Alpha(:,:,z,2)  = dp2.*dp2;
                Alpha(:,:,z,3)  = dp3.*dp3;
                Alpha(:,:,z,4)  = dp1.*dp2;
                Alpha(:,:,z,5)  = dp1.*dp3;
                Alpha(:,:,z,6)  = dp2.*dp3;
                clear tmp p dp1 dp2 dp3
            end

            % Heavy-to-light regularisation
            if ~isfield(obj,'Twarp')
                switch iter
                case 1
                    prm = [param(1:3) 256*param(4:8)];
                case 2
                    prm = [param(1:3) 128*param(4:8)];
                case 3
                    prm = [param(1:3)  64*param(4:8)];
                case 4
                    prm = [param(1:3)  32*param(4:8)];
                case 5
                    prm = [param(1:3)  16*param(4:8)];
                case 6
                    prm = [param(1:3)  8*param(4:8)];
                case 7
                    prm = [param(1:3)  4*param(4:8)];
                case 8
                    prm = [param(1:3)  2*param(4:8)];
                otherwise
                    prm = [param(1:3)    param(4:8)];
                end
            else
                prm = [param(1:3)   param(4:8)];
            end

            % Add in the first derivatives of the prior term
            Beta   = Beta  + spm_diffeo('vel2mom',bsxfun(@times,Twarp,1./sk4),prm);

            % Gauss-Newton increment
            Update = bsxfun(@times,spm_diffeo('fmg',Alpha,Beta,[prm 2 2]),sk4);

            % Line search to ensure objective function improves
            armijo = 1.0;
            for line_search=1:12
                Twarp1 = Twarp - armijo*Update; % Backtrack if necessary

                % Recompute objective function
                llr1 = -0.5*sum(sum(sum(sum(Twarp1.*bsxfun(@times,spm_diffeo('vel2mom',bsxfun(@times,Twarp1,1./sk4),prm),1./sk4)))));
                ll1  = llr1 + llrb;
                if ~use_vbmog
                    ll1 = ll1 + ll_const;
                    for z=1:length(z0)
                        if ~buf(z).nm, continue; end
                        [x1,y1,z1] = defs(Twarp1,z,x0,y0,z0,M,buf(z).msk);
                        b          = spm_sample_logpriors8(logtpm,x1,y1,z1);
                        clear x1 y1 z1
                        s   = zeros(size(b{1}));
                        for k1=1:Kb, b{k1} = b{k1}*wp(k1); s = s + b{k1}; end
                        for k1=1:Kb, b{k1} = b{k1}./s; end

                        sq = zeros(buf(z).nm,1);
                        for k1=1:Kb
                            sq = sq + double(buf(z).dat(:,k1)).*double(b{k1});
                        end
                        clear b
                        ll1 = ll1 + sum(log(sq));
                        clear sq
                    end
                else
                    dll = objval_vb(buf,N,K,Kb,lkp,x0,y0,z0,Twarp1,M,logtpm,mg,po,pr,wp);
                    ll1 = ll1 + dll;
                end

                if ll1<ll
                    % Still not better, so keep searching inwards.                    
                    my_fprintf('Warp:\t%g\t%g\t%g :o(\t(%g)\n', ll1, llr1,llrb,armijo);
                    armijo = armijo*0.75;
                else
                    % Better. Accept the new solution.
                    conv_def(1 + subitdef) = conv_def(1 + subitdef) + 1;
                    
                    spm_plot_convergence('Set',ll1); 
                    my_fprintf('Warp:\t%g\t%g\t%g :o)\t(%g)\n', ll1, llr1,llrb,armijo);
                    ll     = ll1;
                    llr    = llr1;
                    Twarp  = Twarp1;
                    break
                end
            end
            clear Alpha Beta

            if ~isempty(fig{2})
                % Visualise deformed TPM  
                [x1,y1,z1] = defs(Twarp,zslice,x0,y0,z0,M,buf(zslice).msk);
                b          = spm_sample_logpriors8(logtpm,x1,y1,z1);
                clear x1 y1 z1

                K1 = floor(sqrt(Kb));
                K2 = ceil(Kb/K1); 
                set(0,'CurrentFigure',fig{2});                                        
                for i=1:Kb                
                    tmp                  = zeros(size(buf(zslice).msk),'single');
                    tmp(buf(zslice).msk) = b{i};

                    subplot(K1,K2,i);
                    imagesc(tmp'); axis image xy off; colormap(gray);
                end 
                clear b
                drawnow
            end

            if ~((ll-oll)>tol1*nm)
                % Registration no longer helping, so move on
                break
            end
            oll = ll;
        end
    end

    if ~((ll-ooll)>2*tol1*nm) && iter>niter_stop
        % Finished
        break
    end
end

if 0
    fprintf('Convergence (main):\t%g/%g\n',iter,niter);
    fprintf('Convergence (deformation): %s\n', sprintf('%d ', conv_def))
end

if dotpm            
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Estimate template
    %------------------------------------------------------------

    % Compute likelihoods
    lik = zeros([prod(d(1:2)) d(3) Kb],'single');
    for z=1:length(z0)
        if ~buf(z).nm, continue; end
        
        if use_mog || use_vbmog        
            q      = zeros(buf(z).nm,Kb);
            if use_vbmog
                qt = log_likelihoods_vb(buf(z).f,buf(z).bf,po,mg);
            elseif use_mog
                qt = log_likelihoods(buf(z).f,buf(z).bf,mg,mn,vr);
            end
            max_qt = max(qt,[],2);
            for k1=1:Kb
                for k=find(lkp==k1)
                    q(:,k1) = q(:,k1) + exp(qt(:,k) - max_qt);
                end
                lik(buf(z).msk,z,k1) = single(q(:,k1));
            end
            clear qt max_qt q
        else
            q          = log_likelihoods_nonpar(buf(z).f,buf(z).bf,chan);
            max_q      = max(q,[],2);
            q          = exp(bsxfun(@minus,q,max_q));
            for k=1:Kb
                lik(buf(z).msk,z,k) = single(q(:,k));
            end  
            clear q max_q
        end
    end          
    lik = reshape(lik,[d Kb]);    
    clear buf

    if ~isempty(fig{4}) 
        set(0,'CurrentFigure',fig{4});      
        for i=1:Kb
            subplot(2,Kb,i);
            imagesc(lik(:,:,zslice,i)'); axis image xy off; colormap(gray);
        end  
    end
    
    % Push likelihoods to tpm space   
    t       = identity(d) + bsxfun(@times,Twarp,1./sk4); 
    MM      = M*MT;
    t       = affine_transf(MM,t);         
    [lik,c] = spm_diffeo('pushc',lik,t,dtpm);
    clear t                
    
    msk       = isfinite(lik);    
    msk       = bsxfun(@and,msk,c>0);
    lik(~msk) = 0;
    clear msk c
    
    lik = max(lik,eps);
    lik = bsxfun(@rdivide,lik,sum(lik,4));    
    
    if ~isempty(fig{4}) 
        set(0,'CurrentFigure',fig{4});      
        for i=(Kb + 1):2*Kb
            subplot(2,Kb,i);
            imagesc(lik(:,:,floor(logtpm.d(3)/2 + 1),i - Kb)'); axis image xy off; colormap(gray);
        end  
    end
    
    % Solve dF/dmu=0 for mu   
    a1 = zeros([Kb prod(dtpm)],'single'); % Get logs of template
    for k=1:Kb
        a1(k,:) = reshape(logtpm.dat{k},[1 prod(dtpm)]);
    end
    clear logtpm
        
    c1  = log(wp)'; % logs of mixing weights
    c1  = repmat(c1,1,prod(dtpm));
    
    ac = bsxfun(@plus,a1,c1);
    clear a1  

    eac = exp(ac);
    clear ac

    b1 = reshape(lik,[prod(dtpm) Kb]); % likelihoods
    clear lik

    eacb = bsxfun(@times,eac,b1');
    clear b1

    munum = bsxfun(@rdivide,eacb,sum(double(eacb),1)); 
    clear eacb

    munum(~isfinite(munum)) = 0;

    pn = 1./sum(double(eac),1); 
    clear eac

    muden = bsxfun(@times,pn,exp(c1)); 
    clear pn c1

    muden(~isfinite(muden)) = 0;
else
    munum = 0;
    muden = 0;
end

% Save the results
obj.Twarp = Twarp;
obj.Tbias = {chan(:).T};
obj.mg    = mg;
obj.wp    = wp;
obj.ll    = ll;
obj.nm    = nm;
if use_vbmog
    obj.po = po;
    obj.pr = pr;
elseif use_mog
    obj.mn = mn;
    obj.vr = vr;
end
    
return;
%=======================================================================

%=======================================================================
function t = transf(B1,B2,B3,T)
if ~isempty(T)
    d2 = [size(T) 1];
    t1 = reshape(reshape(T, d2(1)*d2(2),d2(3))*B3', d2(1), d2(2));
    t  = B1*t1*B2';
else
    t  = zeros(size(B1,1),size(B2,1));
end
return;
%=======================================================================

%=======================================================================
function L = log_likelihoods(f,bf,mg,mn,vr)
K  = numel(mg);
N  = numel(f);
M  = numel(f{1});

cr = zeros(M,N);
for n=1:N
    if isempty(bf)
        cr(:,n) = double(f{n}(:));
    else
        cr(:,n) = double(f{n}(:)).*double(bf{n}(:));
    end
end

L = zeros(numel(f{1}),K);
for k=1:K
    C      = chol(vr(:,:,k));
    d      = bsxfun(@minus,cr,mn(:,k)')/C;
    L(:,k) = log(mg(k)) - (N/2)*log(2*pi) - sum(log(diag(C))) - 0.5*sum(d.*d,2);
end
%=======================================================================

%=======================================================================
function L = log_likelihoods_vb(f,bf,po,mg)
N = numel(f);
M = numel(f{1});

cr = zeros(M,N);
for n1=1:N
    if isempty(bf)
        cr(:,n1) = double(f{n1}(:));
    else
        cr(:,n1) = double(f{n1}(:)).*double(bf{n1}(:));
    end
end

m = po.m;
n = po.n;
W = po.W;
b = po.b;

K = numel(n);

if nargin<4
    mg = ones(K,1);
end

E          = zeros(M,K);
lnLamTilde = zeros(1,K);
for k=1:K
    t1            = psi(0, 0.5*repmat(n(k)+1,N,1) - 0.5*[1:N]');
    lnLamTilde(k) = sum(t1) + N*log(2)  + LogDet(W(:,:,k));    
    
    diff1  = bsxfun(@minus,cr',m(:,k));
    Q      = chol(W(:,:,k))*diff1;
    E(:,k) = N/b(k) + n(k)*dot(Q,Q,1);
end
L = bsxfun(@plus,-0.5*E,0.5*lnLamTilde);
L = bsxfun(@plus,L,log(mg'));
L = L - N/2*log(2*pi);
%=======================================================================

%=======================================================================
function L = log_likelihoods_nonpar(f,bf,chan)
K  = size(chan(1).lik,1);
Kb = size(chan(1).lik,2);
N  = numel(chan);
L  = zeros(numel(f{1}),Kb);
for n=1:N
    if isempty(bf)
        tmp = f{n}*chan(n).interscal(2) + chan(n).interscal(1);
    else
        tmp = f{n}.*bf{n}*chan(n).interscal(2) + chan(n).interscal(1);
    end
    tmp     = min(max(round(tmp),1),K);
    loglik  = chan(n).alph;
    for k1=1:Kb
        L(:,k1) = L(:,k1)+loglik(tmp,k1);
    end
end
%=======================================================================

%=======================================================================
function B = log_spatial_priors(B,wp)
B = bsxfun(@times,B,wp);
B = log(bsxfun(@times,B,1./sum(B,2)));
%=======================================================================

%=======================================================================
function B = log_spatial_priors_vb(B,wp,lkp,mg)
B = bsxfun(@times,B,wp);
B = bsxfun(@times,B,1./sum(B,2));
B = bsxfun(@times,B(:,lkp),mg');
B = log(B);
%=======================================================================

%=======================================================================
function s = logsumexp(b, dim)
B         = nanmax(b,[],dim);
dims      = ones(1,ndims(b));
dims(dim) = size(b,dim);
b         = b - repmat(B, dims);
s         = B + log(nansum(exp(b),dim));
%=======================================================================

%=======================================================================
function [Q,ll] = latent(f,bf,mg,mn,vr,B,lkp,wp)
B   = log_spatial_priors(B,wp);
Q   = log_likelihoods(f,bf,mg,mn,vr);
Kb  = max(lkp);
for k1=1:Kb
    for k=find(lkp==k1)
        Q(:,k) = Q(:,k) + B(:,k1);
    end
end
[Q,ll] = safe_softmax(Q);
%=======================================================================

%=======================================================================
function [Q,ll] = latent_nonpar(f,bf,chan,B,wp)
B      = log_spatial_priors(B,wp);
Q      = log_likelihoods_nonpar(f,bf,chan);
Q      = Q + B;
[Q,ll] = safe_softmax(Q);
%=======================================================================

%=======================================================================
function [Q,lb] = latent_vb(f,bf,mg,po,B,lkp,wp)
B       = log_spatial_priors_vb(B,wp,lkp,mg);
Q       = log_likelihoods_vb(f,bf,po);
Kb      = max(lkp);
for k1=1:Kb
    for k=find(lkp==k1)
        Q(:,k) = Q(:,k) + B(:,k);
    end
end
logSumQ = logsumexp(Q,2);
logQ    = bsxfun(@minus,Q,logSumQ);
Q       = exp(logQ);

lb = -sum(sum(Q.*logQ));

logbf = ones([numel(bf{1}) 1]);
for n=1:numel(bf)
    logbf = logbf.*bf{n};
end
logbf = repmat(log(logbf),1,size(Q,2));
lb    = lb + sum(sum(Q.*logbf));

lb = lb + sum(sum(Q.*B));
%=======================================================================

%=======================================================================
function [x1,y1,z1] = defs(Twarp,z,x0,y0,z0,M,msk)
x1a = x0    + double(Twarp(:,:,z,1));
y1a = y0    + double(Twarp(:,:,z,2));
z1a = z0(z) + double(Twarp(:,:,z,3));
if nargin>=7
    x1a = x1a(msk);
    y1a = y1a(msk);
    z1a = z1a(msk);
end
[x1,y1,z1] = affine_transf(M,x1a,y1a,z1a);
return;
%=======================================================================

%=======================================================================
function lb = lowerbound_vb(mom0,mom1,mom2,po,pr)
m = po.m;
n = po.n;
W = po.W;
b = po.b;

m0 = pr.m;
n0 = pr.n;
W0 = pr.W;
b0 = pr.b;

[N,K] = size(m0);

lb = 0;
for k=1:K
    logB0 = (n0(k)/2)*LogDet(inv(W0(:,:,k))) - (n0(k)*N/2)*log(2) ...
          - (N*(N-1)/4)*log(pi) - sum(gammaln(0.5*(n0(k)+1 -[1:N])));
  
    t1          = psi(0, 0.5*repmat(n(k)+1,N,1) - 0.5*[1:N]');
    logLamTilde = sum(t1) + N*log(2)  + LogDet(W(:,:,k));
    
    logBk = -(n(k)/2)*LogDet(W(:,:,k)) - (n(k)*N/2)*log(2)...
            - (N*(N-1)/4)*log(pi) - sum(gammaln(0.5*(n(k) + 1 - [1:N])));
    H     = -logBk - 0.5*(n(k) -N-1)*logLamTilde + 0.5*n(k)*N;

    trSW      = trace(n(k)*mom2(:,:,k)*W(:,:,k));
    diff1     = mom1(:,k) - m(:,k);
    xbarWxbar = diff1'*W(:,:,k)*diff1;

    diff1    = m(:,k) - m0(:,k);
    mWm      = b0(k)*n(k)*diff1'*W(:,:,k)*diff1; 
    trW0invW = trace(W0(:,:,k)\W(:,:,k));
    
    lb1 = 0.5*(mom0(k).*(logLamTilde - N./b(k) - trSW - n(k).*xbarWxbar - N*log(2*pi)));
    lb2 = 0.5*(N*log(b0(k)/(2*pi)) + logLamTilde - N*(b0(k)./b(k)) - mWm);
    lb3 = logB0 + 0.5*((n0(k) - N - 1).*logLamTilde) - 0.5*(n(k).*trW0invW);    
    lb4 = 0.5*(logLamTilde + N.*log(b(k)/(2*pi))) - 0.5*N*K - H;
    
    lbk = lb1 + lb2 + lb3 - lb4;
    lb  = lb + lbk;
end
%=======================================================================

%=======================================================================
function po = vmstep_vb(mom0,mom1,mom2,pr)
m0 = pr.m;
n0 = pr.n;
W0 = pr.W;
b0 = pr.b;

[N,K] = size(m0);

b = b0 + mom0';
n = n0 + mom0';
m = zeros(N,K);
W = zeros(N,N,K);
for k = 1:K
    m(:,k) = (b0(k)*m0(:,k) + mom0(k).*mom1(:,k))./b(k);
    
    W0inv    = inv(W0(:,:,k));
    mlt1     = b0(k).*mom0(k)/(b0(k) + mom0(k));
    diff1    = mom1(:,k) - m0(:,k);
    W(:,:,k) = inv(W0inv + mom0(k)*mom2(:,:,k) + mlt1*(diff1*diff1'));
    
    [V,D1]   = eig(W(:,:,k));
    tol      = max(diag(D1))*eps('single');
    D1       = diag(max(diag(D1),tol));
    W(:,:,k) = real(V*D1*V');
end  

po.m = m;
po.b = b;
po.W = W;
po.n = n;
%=======================================================================

%==========================================================================
function [s1B,S2B] = mom_John2Bishop(s0,s1J,S2J)
K = numel(s0);
for k=1:K
    s1B(:,k)   = s1J(:,k)/s0(k);
    S2B(:,:,k) = S2J(:,:,k)/s0(k) - (s1J(:,k)/s0(k))*(s1J(:,k)/s0(k))';
end
%==========================================================================

%==========================================================================
function [s1J,S2J] = mom_Bishop2John(s0,s1B,S2B)
s1J = s0*s1B;
S2J = s0*S2B + s0*(s1J/s0)*(s1J/s0)';
%==========================================================================

%==========================================================================
function lb = objval_vb(buf,N,K,Kb,lkp,x0,y0,z0,Twarp,M,lntpm,mg,po,pr,wp)
lb   = 0;
tiny = eps*eps;
mom0 = zeros(K,1) + tiny; % Initialise moments
mom1 = zeros(N,K);
mom2 = zeros(N,N,K); 
for z=1:length(z0)
    if ~buf(z).nm, continue; end

    [x1,y1,z1] = defs(Twarp,z,x0,y0,z0,M,buf(z).msk);
    b          = spm_sample_logpriors8(lntpm,x1,y1,z1);
    B          = zeros([buf(z).nm Kb]);
    for k=1:Kb
       B(:,k) = b{k};
    end
    clear b x1 y1 z1

    [q,dlb] = latent_vb(buf(z).f,buf(z).bf,mg,po,B,lkp,wp);                                                    
    lb      = lb + dlb; 
    clear B

    cr  = zeros(size(q,1),N);
    for n1=1:N
        cr(:,n1)  = double(buf(z).f{n1}.*buf(z).bf{n1});
    end
    for k=1:K,
        mom0(k)     = mom0(k)     + sum(q(:,k));
        mom1(:,k)   = mom1(:,k)   + (q(:,k)'*cr)';
        mom2(:,:,k) = mom2(:,:,k) + (repmat(q(:,k),1,N).*cr)'*cr;
    end
    clear cr q                                                                       
end

[mom1,mom2] = mom_John2Bishop(mom0,mom1,mom2);
dlb         = lowerbound_vb(mom0,mom1,mom2,po,pr);                    
lb          = lb + dlb; 
clear mom0 mom1 mom2
%==========================================================================

%=======================================================================
function count = my_fprintf(varargin)
if 0
    count = fprintf(varargin{:});
else
    count = 0;
end
%=======================================================================
